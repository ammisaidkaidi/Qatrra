/* esm.sh - @supabase/realtime-js@2.76.1 */
import __Process$ from "/node/process.mjs";
var I=class{static detectEnvironment(){var e;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((e=navigator.userAgent)===null||e===void 0)&&e.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof __Process$<"u"){let t=__Process$.versions;if(t&&t.node){let i=t.node,s=parseInt(i.replace(/^v/,"").split(".")[0]);return s>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${s} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${s} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){let e=this.detectEnvironment();if(e.constructor)return e.constructor;let t=e.error||"WebSocket not supported in this environment.";throw e.workaround&&(t+=`

Suggested solution: ${e.workaround}`),new Error(t)}static createWebSocket(e,t){let i=this.getWebSocketConstructor();return new i(e,t)}static isWebSocketSupported(){try{let e=this.detectEnvironment();return e.type==="native"||e.type==="ws"}catch{return!1}}},M=I;var q="2.76.1";var K=`realtime-js/${q}`,Y="1.0.0";var P=1e4,G=1e3,X=100,L;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(L||(L={}));var u;(function(n){n.closed="closed",n.errored="errored",n.joined="joined",n.joining="joining",n.leaving="leaving"})(u||(u={}));var b;(function(n){n.close="phx_close",n.error="phx_error",n.join="phx_join",n.reply="phx_reply",n.leave="phx_leave",n.access_token="access_token"})(b||(b={}));var D;(function(n){n.websocket="websocket"})(D||(D={}));var R;(function(n){n.Connecting="connecting",n.Open="open",n.Closing="closing",n.Closed="closed"})(R||(R={}));var U=class{constructor(){this.HEADER_LENGTH=1}decode(e,t){return e.constructor===ArrayBuffer?t(this._binaryDecode(e)):t(typeof e=="string"?JSON.parse(e):{})}_binaryDecode(e){let t=new DataView(e),i=new TextDecoder;return this._decodeBroadcast(e,t,i)}_decodeBroadcast(e,t,i){let s=t.getUint8(1),r=t.getUint8(2),o=this.HEADER_LENGTH+2,a=i.decode(e.slice(o,o+s));o=o+s;let h=i.decode(e.slice(o,o+r));o=o+r;let c=JSON.parse(i.decode(e.slice(o,e.byteLength)));return{ref:null,topic:a,event:h,payload:c}}};var C=class{constructor(e,t){this.callback=e,this.timerCalc=t,this.timer=void 0,this.tries=0,this.callback=e,this.timerCalc=t}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}};var d;(function(n){n.abstime="abstime",n.bool="bool",n.date="date",n.daterange="daterange",n.float4="float4",n.float8="float8",n.int2="int2",n.int4="int4",n.int4range="int4range",n.int8="int8",n.int8range="int8range",n.json="json",n.jsonb="jsonb",n.money="money",n.numeric="numeric",n.oid="oid",n.reltime="reltime",n.text="text",n.time="time",n.timestamp="timestamp",n.timestamptz="timestamptz",n.timetz="timetz",n.tsrange="tsrange",n.tstzrange="tstzrange"})(d||(d={}));var J=(n,e,t={})=>{var i;let s=(i=t.skipTypes)!==null&&i!==void 0?i:[];return e?Object.keys(e).reduce((r,o)=>(r[o]=te(o,n,e,s),r),{}):{}},te=(n,e,t,i)=>{let s=e.find(a=>a.name===n),r=s?.type,o=t[n];return r&&!i.includes(r)?Z(r,o):H(o)},Z=(n,e)=>{if(n.charAt(0)==="_"){let t=n.slice(1,n.length);return re(e,t)}switch(n){case d.bool:return ie(e);case d.float4:case d.float8:case d.int2:case d.int4:case d.int8:case d.numeric:case d.oid:return ne(e);case d.json:case d.jsonb:return se(e);case d.timestamp:return oe(e);case d.abstime:case d.date:case d.daterange:case d.int4range:case d.int8range:case d.money:case d.reltime:case d.text:case d.time:case d.timestamptz:case d.timetz:case d.tsrange:case d.tstzrange:return H(e);default:return H(e)}},H=n=>n,ie=n=>{switch(n){case"t":return!0;case"f":return!1;default:return n}},ne=n=>{if(typeof n=="string"){let e=parseFloat(n);if(!Number.isNaN(e))return e}return n},se=n=>{if(typeof n=="string")try{return JSON.parse(n)}catch(e){return console.log(`JSON parse error: ${e}`),n}return n},re=(n,e)=>{if(typeof n!="string")return n;let t=n.length-1,i=n[t];if(n[0]==="{"&&i==="}"){let r,o=n.slice(1,t);try{r=JSON.parse("["+o+"]")}catch{r=o?o.split(","):[]}return r.map(a=>Z(e,a))}return n},oe=n=>typeof n=="string"?n.replace(" ","T"):n,B=n=>{let e=new URL(n);return e.protocol=e.protocol.replace(/^ws/i,"http"),e.pathname=e.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),e.pathname===""||e.pathname==="/"?e.pathname="/api/broadcast":e.pathname=e.pathname+"/api/broadcast",e.href};var S=class{constructor(e,t,i={},s=P){this.channel=e,this.event=t,this.payload=i,this.timeout=s,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(e){this.timeout=e,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(e){this.payload=Object.assign(Object.assign({},this.payload),e)}receive(e,t){var i;return this._hasReceived(e)&&t((i=this.receivedResp)===null||i===void 0?void 0:i.response),this.recHooks.push({status:e,callback:t}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);let e=t=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=t,this._matchReceive(t)};this.channel._on(this.refEvent,{},e),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(e,t){this.refEvent&&this.channel._trigger(this.refEvent,{status:e,response:t})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:e,response:t}){this.recHooks.filter(i=>i.status===e).forEach(i=>i.callback(t))}_hasReceived(e){return this.receivedResp&&this.receivedResp.status===e}};var V;(function(n){n.SYNC="sync",n.JOIN="join",n.LEAVE="leave"})(V||(V={}));var A=class n{constructor(e,t){this.channel=e,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};let i=t?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(i.state,{},s=>{let{onJoin:r,onLeave:o,onSync:a}=this.caller;this.joinRef=this.channel._joinRef(),this.state=n.syncState(this.state,s,r,o),this.pendingDiffs.forEach(h=>{this.state=n.syncDiff(this.state,h,r,o)}),this.pendingDiffs=[],a()}),this.channel._on(i.diff,{},s=>{let{onJoin:r,onLeave:o,onSync:a}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(s):(this.state=n.syncDiff(this.state,s,r,o),a())}),this.onJoin((s,r,o)=>{this.channel._trigger("presence",{event:"join",key:s,currentPresences:r,newPresences:o})}),this.onLeave((s,r,o)=>{this.channel._trigger("presence",{event:"leave",key:s,currentPresences:r,leftPresences:o})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(e,t,i,s){let r=this.cloneDeep(e),o=this.transformState(t),a={},h={};return this.map(r,(c,f)=>{o[c]||(h[c]=f)}),this.map(o,(c,f)=>{let m=r[c];if(m){let _=f.map(p=>p.presence_ref),l=m.map(p=>p.presence_ref),v=f.filter(p=>l.indexOf(p.presence_ref)<0),g=m.filter(p=>_.indexOf(p.presence_ref)<0);v.length>0&&(a[c]=v),g.length>0&&(h[c]=g)}else a[c]=f}),this.syncDiff(r,{joins:a,leaves:h},i,s)}static syncDiff(e,t,i,s){let{joins:r,leaves:o}={joins:this.transformState(t.joins),leaves:this.transformState(t.leaves)};return i||(i=()=>{}),s||(s=()=>{}),this.map(r,(a,h)=>{var c;let f=(c=e[a])!==null&&c!==void 0?c:[];if(e[a]=this.cloneDeep(h),f.length>0){let m=e[a].map(l=>l.presence_ref),_=f.filter(l=>m.indexOf(l.presence_ref)<0);e[a].unshift(..._)}i(a,f,h)}),this.map(o,(a,h)=>{let c=e[a];if(!c)return;let f=h.map(m=>m.presence_ref);c=c.filter(m=>f.indexOf(m.presence_ref)<0),e[a]=c,s(a,c,h),c.length===0&&delete e[a]}),e}static map(e,t){return Object.getOwnPropertyNames(e).map(i=>t(i,e[i]))}static transformState(e){return e=this.cloneDeep(e),Object.getOwnPropertyNames(e).reduce((t,i)=>{let s=e[i];return"metas"in s?t[i]=s.metas.map(r=>(r.presence_ref=r.phx_ref,delete r.phx_ref,delete r.phx_ref_prev,r)):t[i]=s,t},{})}static cloneDeep(e){return JSON.parse(JSON.stringify(e))}onJoin(e){this.caller.onJoin=e}onLeave(e){this.caller.onLeave=e}onSync(e){this.caller.onSync=e}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}};var z;(function(n){n.ALL="*",n.INSERT="INSERT",n.UPDATE="UPDATE",n.DELETE="DELETE"})(z||(z={}));var N;(function(n){n.BROADCAST="broadcast",n.PRESENCE="presence",n.POSTGRES_CHANGES="postgres_changes",n.SYSTEM="system"})(N||(N={}));var y;(function(n){n.SUBSCRIBED="SUBSCRIBED",n.TIMED_OUT="TIMED_OUT",n.CLOSED="CLOSED",n.CHANNEL_ERROR="CHANNEL_ERROR"})(y||(y={}));var ce=u,x=class n{constructor(e,t={config:{}},i){var s,r;if(this.topic=e,this.params=t,this.socket=i,this.bindings={},this.state=u.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=e.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},t.config),this.timeout=this.socket.timeout,this.joinPush=new S(this,b.join,this.params,this.timeout),this.rejoinTimer=new C(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=u.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(o=>o.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=u.closed,this.socket._remove(this)}),this._onError(o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=u.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=u.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=u.errored,this.rejoinTimer.scheduleTimeout())}),this._on(b.reply,{},(o,a)=>{this._trigger(this._replyEventName(a),o)}),this.presence=new A(this),this.broadcastEndpointURL=B(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((r=(s=this.params.config)===null||s===void 0?void 0:s.broadcast)===null||r===void 0)&&r.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(e,t=this.timeout){var i,s,r;if(this.socket.isConnected()||this.socket.connect(),this.state==u.closed){let{config:{broadcast:o,presence:a,private:h}}=this.params,c=(s=(i=this.bindings.postgres_changes)===null||i===void 0?void 0:i.map(l=>l.filter))!==null&&s!==void 0?s:[],f=!!this.bindings[N.PRESENCE]&&this.bindings[N.PRESENCE].length>0||((r=this.params.config.presence)===null||r===void 0?void 0:r.enabled)===!0,m={},_={broadcast:o,presence:Object.assign(Object.assign({},a),{enabled:f}),postgres_changes:c,private:h};this.socket.accessTokenValue&&(m.access_token=this.socket.accessTokenValue),this._onError(l=>e?.(y.CHANNEL_ERROR,l)),this._onClose(()=>e?.(y.CLOSED)),this.updateJoinPayload(Object.assign({config:_},m)),this.joinedOnce=!0,this._rejoin(t),this.joinPush.receive("ok",async({postgres_changes:l})=>{var v;if(this.socket.setAuth(),l===void 0){e?.(y.SUBSCRIBED);return}else{let g=this.bindings.postgres_changes,p=(v=g?.length)!==null&&v!==void 0?v:0,E=[];for(let k=0;k<p;k++){let w=g[k],{filter:{event:T,schema:j,table:Q,filter:ee}}=w,O=l&&l[k];if(O&&O.event===T&&O.schema===j&&O.table===Q&&O.filter===ee)E.push(Object.assign(Object.assign({},w),{id:O.id}));else{this.unsubscribe(),this.state=u.errored,e?.(y.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=E,e&&e(y.SUBSCRIBED);return}}).receive("error",l=>{this.state=u.errored,e?.(y.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(l).join(", ")||"error")))}).receive("timeout",()=>{e?.(y.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(e,t={}){return await this.send({type:"presence",event:"track",payload:e},t.timeout||this.timeout)}async untrack(e={}){return await this.send({type:"presence",event:"untrack"},e)}on(e,t,i){return this.state===u.joined&&e===N.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(()=>this.subscribe())),this._on(e,t,i)}async httpSend(e,t,i={}){var s;let r=this.socket.accessTokenValue?`Bearer ${this.socket.accessTokenValue}`:"";if(t==null)return Promise.reject("Payload is required for httpSend()");let o={method:"POST",headers:{Authorization:r,apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"},body:JSON.stringify({messages:[{topic:this.subTopic,event:e,payload:t,private:this.private}]})},a=await this._fetchWithTimeout(this.broadcastEndpointURL,o,(s=i.timeout)!==null&&s!==void 0?s:this.timeout);if(a.status===202)return{success:!0};let h=a.statusText;try{let c=await a.json();h=c.error||c.message||h}catch{}return Promise.reject(new Error(h))}async send(e,t={}){var i,s;if(!this._canPush()&&e.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");let{event:r,payload:o}=e,h={method:"POST",headers:{Authorization:this.socket.accessTokenValue?`Bearer ${this.socket.accessTokenValue}`:"",apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"},body:JSON.stringify({messages:[{topic:this.subTopic,event:r,payload:o,private:this.private}]})};try{let c=await this._fetchWithTimeout(this.broadcastEndpointURL,h,(i=t.timeout)!==null&&i!==void 0?i:this.timeout);return await((s=c.body)===null||s===void 0?void 0:s.cancel()),c.ok?"ok":"error"}catch(c){return c.name==="AbortError"?"timed out":"error"}}else return new Promise(r=>{var o,a,h;let c=this._push(e.type,e,t.timeout||this.timeout);e.type==="broadcast"&&!(!((h=(a=(o=this.params)===null||o===void 0?void 0:o.config)===null||a===void 0?void 0:a.broadcast)===null||h===void 0)&&h.ack)&&r("ok"),c.receive("ok",()=>r("ok")),c.receive("error",()=>r("error")),c.receive("timeout",()=>r("timed out"))})}updateJoinPayload(e){this.joinPush.updatePayload(e)}unsubscribe(e=this.timeout){this.state=u.leaving;let t=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(b.close,"leave",this._joinRef())};this.joinPush.destroy();let i=null;return new Promise(s=>{i=new S(this,b.leave,{},e),i.receive("ok",()=>{t(),s("ok")}).receive("timeout",()=>{t(),s("timed out")}).receive("error",()=>{s("error")}),i.send(),this._canPush()||i.trigger("ok",{})}).finally(()=>{i?.destroy()})}teardown(){this.pushBuffer.forEach(e=>e.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=u.closed,this.bindings={}}async _fetchWithTimeout(e,t,i){let s=new AbortController,r=setTimeout(()=>s.abort(),i),o=await this.socket.fetch(e,Object.assign(Object.assign({},t),{signal:s.signal}));return clearTimeout(r),o}_push(e,t,i=this.timeout){if(!this.joinedOnce)throw`tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let s=new S(this,e,t,i);return this._canPush()?s.send():this._addToPushBuffer(s),s}_addToPushBuffer(e){if(e.startTimeout(),this.pushBuffer.push(e),this.pushBuffer.length>X){let t=this.pushBuffer.shift();t&&(t.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${t.event}`,t.payload))}}_onMessage(e,t,i){return t}_isMember(e){return this.topic===e}_joinRef(){return this.joinPush.ref}_trigger(e,t,i){var s,r;let o=e.toLocaleLowerCase(),{close:a,error:h,leave:c,join:f}=b;if(i&&[a,h,c,f].indexOf(o)>=0&&i!==this._joinRef())return;let _=this._onMessage(o,t,i);if(t&&!_)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(o)?(s=this.bindings.postgres_changes)===null||s===void 0||s.filter(l=>{var v,g,p;return((v=l.filter)===null||v===void 0?void 0:v.event)==="*"||((p=(g=l.filter)===null||g===void 0?void 0:g.event)===null||p===void 0?void 0:p.toLocaleLowerCase())===o}).map(l=>l.callback(_,i)):(r=this.bindings[o])===null||r===void 0||r.filter(l=>{var v,g,p,E,k,w;if(["broadcast","presence","postgres_changes"].includes(o))if("id"in l){let T=l.id,j=(v=l.filter)===null||v===void 0?void 0:v.event;return T&&((g=t.ids)===null||g===void 0?void 0:g.includes(T))&&(j==="*"||j?.toLocaleLowerCase()===((p=t.data)===null||p===void 0?void 0:p.type.toLocaleLowerCase()))}else{let T=(k=(E=l?.filter)===null||E===void 0?void 0:E.event)===null||k===void 0?void 0:k.toLocaleLowerCase();return T==="*"||T===((w=t?.event)===null||w===void 0?void 0:w.toLocaleLowerCase())}else return l.type.toLocaleLowerCase()===o}).map(l=>{if(typeof _=="object"&&"ids"in _){let v=_.data,{schema:g,table:p,commit_timestamp:E,type:k,errors:w}=v;_=Object.assign(Object.assign({},{schema:g,table:p,commit_timestamp:E,eventType:k,new:{},old:{},errors:w}),this._getPayloadRecords(v))}l.callback(_,i)})}_isClosed(){return this.state===u.closed}_isJoined(){return this.state===u.joined}_isJoining(){return this.state===u.joining}_isLeaving(){return this.state===u.leaving}_replyEventName(e){return`chan_reply_${e}`}_on(e,t,i){let s=e.toLocaleLowerCase(),r={type:s,filter:t,callback:i};return this.bindings[s]?this.bindings[s].push(r):this.bindings[s]=[r],this}_off(e,t){let i=e.toLocaleLowerCase();return this.bindings[i]&&(this.bindings[i]=this.bindings[i].filter(s=>{var r;return!(((r=s.type)===null||r===void 0?void 0:r.toLocaleLowerCase())===i&&n.isEqual(s.filter,t))})),this}static isEqual(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(let i in e)if(e[i]!==t[i])return!1;return!0}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(e){this._on(b.close,{},e)}_onError(e){this._on(b.error,{},t=>e(t))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(e=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=u.joining,this.joinPush.resend(e))}_getPayloadRecords(e){let t={new:{},old:{}};return(e.type==="INSERT"||e.type==="UPDATE")&&(t.new=J(e.columns,e.record)),(e.type==="UPDATE"||e.type==="DELETE")&&(t.old=J(e.columns,e.old_record)),t}};var F=()=>{},$={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},he=[1e3,2e3,5e3,1e4],le=1e4,de=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`,W=class{constructor(e,t){var i;if(this.accessTokenValue=null,this.apiKey=null,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=P,this.transport=null,this.heartbeatIntervalMs=$.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=F,this.ref=0,this.reconnectTimer=null,this.logger=F,this.conn=null,this.sendBuffer=[],this.serializer=new U,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=s=>{let r;return s?r=s:typeof fetch>"u"?r=(...o)=>import("/@supabase/node-fetch@2.6.15/es2022/node-fetch.mjs").then(({default:a})=>a(...o)).catch(a=>{throw new Error(`Failed to load @supabase/node-fetch: ${a.message}. This is required for HTTP requests in Node.js environments without native fetch.`)}):r=fetch,(...o)=>r(...o)},!(!((i=t?.params)===null||i===void 0)&&i.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=t.params.apikey,this.endPoint=`${e}/${D.websocket}`,this.httpEndpoint=B(e),this._initializeOptions(t),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(t?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=M.createWebSocket(this.endpointURL())}catch(e){this._setConnectionState("disconnected");let t=e.message;throw t.includes("Node.js")?new Error(`${t}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${t}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:Y}))}disconnect(e,t){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){let i=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(i),this._setConnectionState("disconnected")},e?this.conn.close(e,t??""):this.conn.close(),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(e){let t=await e.unsubscribe();return this.channels.length===0&&this.disconnect(),t}async removeAllChannels(){let e=await Promise.all(this.channels.map(t=>t.unsubscribe()));return this.channels=[],this.disconnect(),e}log(e,t,i){this.logger(e,t,i)}connectionState(){switch(this.conn&&this.conn.readyState){case L.connecting:return R.Connecting;case L.open:return R.Open;case L.closing:return R.Closing;default:return R.Closed}}isConnected(){return this.connectionState()===R.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(e,t={config:{}}){let i=`realtime:${e}`,s=this.getChannels().find(r=>r.topic===i);if(s)return s;{let r=new x(`realtime:${e}`,t,this);return this.channels.push(r),r}}push(e){let{topic:t,event:i,payload:s,ref:r}=e,o=()=>{this.encode(e,a=>{var h;(h=this.conn)===null||h===void 0||h.send(a)})};this.log("push",`${t} ${i} (${r})`,s),this.isConnected()?o():this.sendBuffer.push(o)}async setAuth(e=null){this._authPromise=this._performAuth(e);try{await this._authPromise}finally{this._authPromise=null}}async sendHeartbeat(){var e;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(t){this.log("error","error in heartbeat callback",t)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(t){this.log("error","error in heartbeat callback",t)}this._wasManualDisconnect=!1,(e=this.conn)===null||e===void 0||e.close(G,"heartbeat timeout"),setTimeout(()=>{var t;this.isConnected()||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout()},$.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(t){this.log("error","error in heartbeat callback",t)}this._setAuthSafely("heartbeat")}onHeartbeat(e){this.heartbeatCallback=e}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(e=>e()),this.sendBuffer=[])}_makeRef(){let e=this.ref+1;return e===this.ref?this.ref=0:this.ref=e,this.ref.toString()}_leaveOpenTopic(e){let t=this.channels.find(i=>i.topic===e&&(i._isJoined()||i._isJoining()));t&&(this.log("transport",`leaving duplicate topic "${e}"`),t.unsubscribe())}_remove(e){this.channels=this.channels.filter(t=>t.topic!==e.topic)}_onConnMessage(e){this.decode(e.data,t=>{if(t.topic==="phoenix"&&t.event==="phx_reply")try{this.heartbeatCallback(t.payload.status==="ok"?"ok":"error")}catch(c){this.log("error","error in heartbeat callback",c)}t.ref&&t.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);let{topic:i,event:s,payload:r,ref:o}=t,a=o?`(${o})`:"",h=r.status||"";this.log("receive",`${h} ${i} ${s} ${a}`.trim(),r),this.channels.filter(c=>c._isMember(i)).forEach(c=>c._trigger(s,r,o)),this._triggerStateCallbacks("message",t)})}_clearTimer(e){var t;e==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):e==="reconnect"&&((t=this.reconnectTimer)===null||t===void 0||t.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=e=>this._onConnError(e),this.conn.onmessage=e=>this._onConnMessage(e),this.conn.onclose=e=>this._onConnClose(e))}_teardownConnection(){this.conn&&(this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null),this._clearAllTimers(),this.channels.forEach(e=>e.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),this.flushSendBuffer(),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");let e=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(e),this.workerRef.onerror=t=>{this.log("worker","worker error",t.message),this.workerRef.terminate()},this.workerRef.onmessage=t=>{t.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_onConnClose(e){var t;this._setConnectionState("disconnected"),this.log("transport","close",e),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout(),this._triggerStateCallbacks("close",e)}_onConnError(e){this._setConnectionState("disconnected"),this.log("transport",`${e}`),this._triggerChanError(),this._triggerStateCallbacks("error",e)}_triggerChanError(){this.channels.forEach(e=>e._trigger(b.error))}_appendParams(e,t){if(Object.keys(t).length===0)return e;let i=e.match(/\?/)?"&":"?",s=new URLSearchParams(t);return`${e}${i}${s}`}_workerObjectUrl(e){let t;if(e)t=e;else{let i=new Blob([de],{type:"application/javascript"});t=URL.createObjectURL(i)}return t}_setConnectionState(e,t=!1){this._connectionState=e,e==="connecting"?this._wasManualDisconnect=!1:e==="disconnecting"&&(this._wasManualDisconnect=t)}async _performAuth(e=null){let t;e?t=e:this.accessToken?t=await this.accessToken():t=this.accessTokenValue,this.accessTokenValue!=t&&(this.accessTokenValue=t,this.channels.forEach(i=>{let s={access_token:t,version:K};t&&i.updateJoinPayload(s),i.joinedOnce&&i._isJoined()&&i._push(b.access_token,{access_token:t})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(e="general"){this.setAuth().catch(t=>{this.log("error",`error setting auth in ${e}`,t)})}_triggerStateCallbacks(e,t){try{this.stateChangeCallbacks[e].forEach(i=>{try{i(t)}catch(s){this.log("error",`error in ${e} callback`,s)}})}catch(i){this.log("error",`error triggering ${e} callbacks`,i)}}_setupReconnectionTimer(){this.reconnectTimer=new C(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},$.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(e){var t,i,s,r,o,a,h,c,f;if(this.transport=(t=e?.transport)!==null&&t!==void 0?t:null,this.timeout=(i=e?.timeout)!==null&&i!==void 0?i:P,this.heartbeatIntervalMs=(s=e?.heartbeatIntervalMs)!==null&&s!==void 0?s:$.HEARTBEAT_INTERVAL,this.worker=(r=e?.worker)!==null&&r!==void 0?r:!1,this.accessToken=(o=e?.accessToken)!==null&&o!==void 0?o:null,this.heartbeatCallback=(a=e?.heartbeatCallback)!==null&&a!==void 0?a:F,e?.params&&(this.params=e.params),e?.logger&&(this.logger=e.logger),(e?.logLevel||e?.log_level)&&(this.logLevel=e.logLevel||e.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=e?.reconnectAfterMs)!==null&&h!==void 0?h:(m=>he[m-1]||le),this.encode=(c=e?.encode)!==null&&c!==void 0?c:((m,_)=>_(JSON.stringify(m))),this.decode=(f=e?.decode)!==null&&f!==void 0?f:this.serializer.decode.bind(this.serializer),this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=e?.workerUrl}}};export{ce as REALTIME_CHANNEL_STATES,N as REALTIME_LISTEN_TYPES,z as REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,V as REALTIME_PRESENCE_LISTEN_EVENTS,y as REALTIME_SUBSCRIBE_STATES,x as RealtimeChannel,W as RealtimeClient,A as RealtimePresence,M as WebSocketFactory};
//# sourceMappingURL=realtime-js.mjs.map